:project-name: Mallard MMU
:imagesdir: ../assets/images/mmu
= {project-name} Micro-Architecture Specification (MAS)
Andrew Waterman <aswaterman@sifive.com>; Josh Smith <jsmith@sifive.com>; John Ingalls <john.ingalls@sifive.com>; Warren Menezes <warren.menezes@sifive.com>; Sihao Liu <sihao.liu@sifive.com>
v2.1, {localdate}
:toc:
:toclevels: 5
//:xrefstyle: full
:sectnums:

== Revision History
[cols="1,3", options="header"]
|===
|Version    | Notes
|1.0        | Supervisor 1.11
|2.0        | Hypervisor 0.6
|2.1        | Multiple PTW introduced
|===

<<<
== Overview
This section provides more detail on the virtual-to-physical address translation hardware in the {project-name}.
The main components are the L2 Unified TLB, the Page Table Walkers (PTWs) and the Page Cache.

=== Generator parameters
* Core XLen = RV32 (Sv32) or RV64 (Sv39, Sv48, Sv57).
* Address sizes input and output.
* PTW number of outstanding page table walk.
* Translation table levels = 2 (Sv32), 3 (Sv39), 4 (Sv48), 5 (Sv57).
* L2TLB capacity number of entries.
* L2TLB associativity number of ways.
* L2TLB capacity number of 2MB superpage entries.
* L2TLB associativity number of 2MB superpage ways.
* PTE Cache number of entries.
* Hypervisor present or not.

== Glossary

=== Acronyms
[options="header"]
[cols="2*"]
[%autowidth]
|===
| Term    | Definition
| ASID    | Address Space ID
| CSR     | Control/Status Register
| D-Cache | Data Cache
| DTLB    | Data Translation Lookaside Buffer
| ECC     | Error Correcting Codes
| FSM     | Finite State Machine
| GPA     | Guest Physical Address
| I-Cache | Instruction Cache
| ITLB    | Instruction Translation Lookaside Buffer
| L2TLB   | Level-2 TLB (a.k.a. UTLB)
| MMU     | Memory Management Unit
| PA      | Physical Address
| PMP     | Physical Memory Protection
| PPN     | Physical Page Number
| PTW     | Page Table Walker
| PTE     | Page Table Entry
| PTE$    | PTE walk cache
| RAM     | Random Access Memory
| SRAM    | Static Random Access Memory
| TLB     | Translation Lookaside Buffer
| TLBI    | TLB Invalidate
| UTLB    | Unified TLB (a.k.a. L2TLB)
| VA      | Virtual Address
| VMID    | Virtual Machine ID
| VPN     | Virtual Page Number
|===

== Memory Management Unit (MMU)
The Memory Management Unit (MMU) is responsible for translating virtual addresses to physical addresses by
walking through the page tables which reside in memory. 

The MMU has a hardware state machine -- 
Page Table Walker, PTW, which issues memory requests to fetch Page Table Entries (PTEs) until a leaf 
PTE has been found or a page fault condition is encountered. The Page Table Walker will send memory 
requests for PTEs to the D-Cache. The resulting physical address and permissions bits will be 
returned to the requestor, along with any
necessary fault information.

Due to the long latency nature of walking the page tables, and the number of outstanding memory operations in
the core, it is desirable for the PTW to be able to process multiple outstanding table walks in parallel. 
While the Rocket's MMU only supports one outstanding page table walk, the Mallard MMU supports multiple page 
table walk at the same time. The number of maximum outstanding page table walk (`nPTW`) is parameterizable, 
which is used to instantiate `nPTW` PTWs hardware modules.

Besides multiple PTWs, MMU contains at least one (up to two with hypervisor enabled) Page Table Entry Walk Caches (PTE$), serving as small buffer to explore the temporal locality of page walk, reducing the latency of accessing
D-cache. These two PTE$s are shared by all PTWs.

L2 Unified Translation Lookaside Buffer (L2TLB) serves as last-level cache to explore the locality of both I-TLB and D-TLB. Optionally, there is an identical parallel pipeline for 2MB superpage entries in addition to 4KB last-level page entries.

Figure <<MallardMMUOverview>> shows the organization of Mallard MMU.

[[MallardMMUOverview]]
.Mallard MMU Overview
image::Mallard_MMU_Overview.png[]

- *CSRs* (`xatp`, `xstatus`, `pmp`, `custom`) are from CSRFile outputs to PTW inputs,
and anywhere else in the Tile that wants to tap them too.
- *SFence* is from Core output to PTW input, and TLBs anywhere else that want to tap this too.
- *Perf* is from PTW output to PerfMon input.

=== PTW State Machine (FSM)

:rocket_fsm:  https://github.com/sifive/arch-specs/blob/master/core/rocket_mmu_mas.adoc#42-ptw-state-machine-fsm[Rocket's PTW FSM]

The Mallard's PTW FSM design is almost the same as the one of Rocket's, except that the transition from `ready` to 
`req` is not triggered by `request_arb.out.fire` but by the fire of `PTE Start Arbiter` shown in Figure <<PTWPipeline>> and <<PTWFSM>>.

The former arbiter is used to assign the PTW request to idle PTW FSM, while the latter one is used to decide which PTW FSM 
takes the resource (PTE$, L2 TLB and Memory Interface)

[[PTWPipeline]]
.Pipeline of a PTW3 Design
image::Mallard_MMU_Pipeline.png[]

To illustrate the pipeline design of MMU that support multiple outstanding PTWs. 
Figure <<PTWPipeline>> is an example design with 4 PTW Request Ports and up to 3 PTWs, 
showing the number of PTW request ports can be different from the number of actual PTW FSMs.

The PTW Requests will first go through an Round-Robin Arbiter, 
where only one PTW request can be assigned to one of idle PTW FSMs per cycle.

The assignment of PTW request triggers the state transition from `ready` to `req`, 
if there are other PTW FSMs are in `req` state, as shown in Figure <<PTWFSM>>.

[[PTWFSM]]
.Finite State Machine of Single PTW
image::Mallard_PTW_FSM.png[]

The assignment of PTW request (requestor_arb.out.fire) will kick-start the finite state machine of PTW, 
which raises the valid bit of PTE Start Arbiter. 
Such assignment will also record the original requestor ID (the index of the requestor port, `r_req_dset`) inside each PTW, 
for further use of PTW's response.

The fire of PTW requestor arbiter switches the state of each PTW FSM into `req` if there are other PTWs' FSM in `req` state.
The meaning of `req` state of Mallard's MMU is different from the `req` state of Rocket design, where `req` state of Rocket's MMU means the PTW is actually using the resource -- accessing PTE$, L2 TLB(s) and Memory Interface.
The `req` state of Mallard MMU means that the current PTW has the *potential* of winning the resource, by raising the valid bit of `PTE Start Arbiter` input port.
It will stay at `req` state if it does not win arbitration, OR if it does win the arbitration while PTE$ cache hit or memory interface is not ready.

For PTW with state == `req`, if the memory interface is also ready, it will switch to `wait1` and continues as Rocket's design.

The pipeline of Mallard MMU (shown as Figure <<PTWPipeline>>) is quite similar to {rocket_fsm}, where *PTE$*, *L2 TLB* and *Memory Request* are accessed at the same time. 

An hit on L2 TLB will stop the ongoing memory transaction by `s1_kill`. 
Because the access to memory interface is triggered by `PTE Start Arbiter`, so no memory request arbiter required.
But there is a Memory Request Mux that uses PTE Start Arbiter's `chosen` signal to select the correct PTW to perform memory request. 

When a valid memory response received, it will update the `r_pte` register to continue further page table walk, which also triggers
refill to the L2 TLB.

A finalized page table walking will raise the valid bit of `io.requestor(r_req_dest).resp.valid`, 
where `r_req_dest` is recorded at the beginning of page table walk.

The registers that either dedicated to each PTW FSM or shared by all PTW FSMs are listed as below.

*Dedicated registers for PTW response signals*
[options="header"]
[cols="3*"]
[%autowidth]
|===
| Name              | Width                     | Function
| state             | 4-bit                     | State register of FSM (refer <<PTWFSM>>)
| count             | `log2Ceil(pgLevels)`-bit  | The current page level of outer page walk
| resp_ae_ptw       | 1-bit                     | Access error happens during Page Walking
| resp_ae_final     | 1-bit                     | Access error at the end of PTW (leaf PTE access error)
| resp_pf           | 1-bit                     | Page Fault
| resp_gf           | 1-bit                     | Guest Page Fault
| resp_hr           | 1-bit                     | Hypervisor read error
| resp_hw           | 1-bit                     | Hypervisor write error
| resp_hx           | 1-bit                     | Hypervisor execution error
| resp_fragmented_superpage | 1-bit             | Response is fragmented superpage
|===

*Dedicated registers with PTW request and other meta information*
[options="header"]
[cols="3*"]
[%autowidth]
|===
| Name                  | Width             | Function
| r_req                 | `PTWReq`-bit      | Register that holds PTW request
| r_req_dest            | `log2Ceil(n)`-bit | The PTW request source port index (`n` is number of PTW request port)
| r_pte                 | `PTE`-bit         | Outstanding PTW during page walk
| r_hgatp               | `PTBR`-bit        | The page table base address register
| r_asid                | `asIdBits`-bit    | Address Space ID (if hypervisor enabled)
| r_vmid                | `vmIdBits`-bit    | Virtual Machine ID (if hypervisor enabled)
|===

*Dedicated registers related to PTW with Hypervisor*
[options="header"]
[cols="3*"]
[%autowidth]
|===
| Name        | Width                     | Function
| aux_count   | `log2Ceil(pgLevels)`-bit  | The outstanding page level of inner nested walk (if hypervisor enabled)
| aux_pte     | `PTE.getWidth`-bit        | The outstanding Page Table Entry of inner nested walk (if hypervisor enabled)
| gpa_pgoff   | `pgIdxBits`-bit           | Guest physical address page offset
| stage2      | 1-bit                     | If the current walk is for inner nested walk (guest mode)
| stage2_final| 1-bit                     | If the inner nested walk for guest mode is finalized
|===

*Shared register(s) related to PTE invalidation*
[options="header"]
[cols="3*"]
[%autowidth]
|===
| Name              | Width | Function
| invalidated       | 1-bit | Invalidate PTE triggered by `sfence` instruction
|===

=== PTE walk cache (PTE$)

:rocket_pte:  https://github.com/sifive/arch-specs/blob/master/core/rocket_mmu_mas.adoc#pte-walk-cache-pte[Rocket's PTE Cache]


The PTE Cache design is same as {rocket_pte}, the only difference is that Mallard’s PTE$ is shared by multiple PTW FSMs.

=== PTW request for faulting GPA

:rocket_gpa_fault: https://github.com/sifive/arch-specs/blob/master/core/rocket_mmu_mas.adoc#ptw-request-for-faulting-gpa[Rocket's design]

Same as {rocket_gpa_fault}

== L2 Unified TLB (L2TLB  )

:rocket_l2tlb: https://github.com/sifive/arch-specs/blob/master/core/rocket_mmu_mas.adoc#5-l2-unified-tlb-l2tlb[Rocket's L2 TLB]

The L2 TLB pipeline design is the same as {rocket_l2tlb}, the only difference is that Mallard's L2 TLB is 
shared by multiple PTW FSMs.

== ASID/VMID Tagging

:rocket_asid_vmid: https://github.com/sifive/arch-specs/blob/master/core/rocket_mmu_mas.adoc#6-asidvmid-tagging[Rocket's design]

Same as {rocket_asid_vmid}

== TLB Invalidations (TLBI)

:rocket_tlbi: https://github.com/sifive/arch-specs/blob/master/core/rocket_mmu_mas.adoc#7-tlb-invalidations-tlbi[Rocket's design]

Same as {rocket_tlbi}